// * 7.0 На прошлом уроке мы уже рассмотрели пользу "union types", но мы можем пойти ещё дальше, дав им, что называется "type aliases". Чтобы задать типу алиас мы пишем ключевое слово "type", а затем имя алиаса. Затем указываем типы присваивая значение. И мы подставим туда "union types", которое уже прописывали аргументу в функции. Теперь мы можем использовать алиас на их месте, а также это даёт возможность переиспользования алиаса типа снова и снова.

type Sizes = 'small' | 'medium' | 'large';

function setProductSize2(size: Sizes) {
  // ... some code
}

setProductSize2('large');

// 7.1.0 И, хотя алисы наверное более всего полезны для "union types", они применимы не только для них. Они могут применяться для любого типа. Например, для типа строки:

type myString = string;

// 7.1.1 Или даже на кастомные для числа:

type successCode = 200;

// 7.1.2 Или даже для комбинации:
// ? Большинство из них не слишком применимы на практике, но хорошо об этом тоже знать, ведь однажды это может пригодиться.

type someType = 1 | string;

// 7.2.0 Также алиасы типов могут применяться и на буквенные обозначения объектов

type Product = {
  name: string;
  price: number;
};

// 7.2.1 Теперь, если мы создадим переменную с типом "Product", то TS будет ругаться, пока мы не укажем внутри этого объекта свойства "name" & "price" соответствующих типов данных.
// ? Хотя такой подход возможен, но лучшей практикой для описания типов объектов считается interface, а не алиас типов.

const tShirt: Product = {
  name: 'Mega Cool T-Shirt',
  price: 8,
};
