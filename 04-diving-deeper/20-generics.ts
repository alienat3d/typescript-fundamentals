// * 18.0 "Дженерики"/универсальные шаблоны («generics»).
// ? 18.1 Функция "clone" будет делать глубокое клонирование переданных значений с помощью методов объекта JSON "stringify" & "parse". Это вполне себе обычный способ клонирования названных объектов и массивов. Иногда это необходимо, т.к. объекты ссылочный тип данных и просто так не клонируются, как это делают примитивные типы данных. А превращение их в JSON-строку с последующим распарсиванием обратно в объект создаёт точную копию это объекта, т.е. делает клон, не связанный с оригиналом.
// 18.2 Мы также можем заметить, что TS говорит, что хотел бы более конкретного определения типа для получаемого функцией аргумента "value". Мы можем поставить "any", но тогда функция становится бесполезной. Почему так? Для демонстрации создадим interface Person

interface Person {
  name: string;
  age: number;
}

// 18.3 Затем мы создадим переменную "me", которая будет следовать правилам interface "Person".

const me: Person = {
  name: 'Al',
  age: 38,
};

// 18.4 Но теперь, после клонирования объекта "me" в "myClone" мы больше не можем обратиться к содержимому, как раньше, а всё потому, что мы указали типом для "value" — "any" и он автоматически создал тип "any" для возвращаемого результата. Попробуем заменить на "Person".
// 18.6 Однако это сильно ограничивает функцию "clone", ведь она теперь заточена только на тип Person, а хотелось бы, чтобы она работала на любой именованный объект или массив. Здесь выходят на сцену дженерики, с помощью которых мы можем сказать TS, что какой бы тип не был бы указан для value, тот же тип данных и должен быть возвращён функцией. А выглядеть это будет так:
/* 18.7 Рассмотрим что же это значит по порядку:
 * Вначале мы написали <Type>, что называется "переменная типа" (и, кстати, она не должна называться "Type", а может иметь любое название, например, её часто сокращают до "T"), можно также её представлять чем-то вроде параметра для функции, но для типа.
 * Затем мы говорим, что параметр "value" должен быть такого же типа, как переменная "Type".
 * Наконец, мы говорим, что результатом должны быть данных того же типа, что и переменная "Type" и параметр "Value". */

// const clone = (value: any) => {
// const clone = (value: Person): Person => {
const clone = <Type>(value: Type): Type => {
  const json = JSON.stringify(value);
  return JSON.parse(json);
};

const myClone = clone(me);

// 18.5 Теперь способности TS предлагать нам список содержимого объекта вернулась.
// 18.8 Теперь TS будет снова нам предлагать все свойства каждого объекта в выпадающем списке. Но при этом можно клонировать той же функцией что-то ещё, помимо типа Person. Попробуем также с массивом строк. Теперь TS всё ещё понимает, что клон массива строк это всё ещё массив строк и мы можем легко выбрать из списка нужный нам метод массива, при работе с ним.

myClone.name;

const moviesByDavidLynch: string[] = [
  'Twin Peaks',
  'Mulholland Drive',
  'Eraserhead',
  'The Straight Story',
];

// 18.9 Но, как мы явно указывали типы, мы можем указывать и тип переменной в угловых скобках таким образом:

const moviesByDavidLynchClone = clone<string[]>(moviesByDavidLynch);

moviesByDavidLynchClone.push('Blue Velvet');

// ? 18.10 Дженерики не ограничиваются в использовании на параметрах и результате функций и могут быть использованы при определении типов, интерфейсов и классов (см. ссылки).
